package com.example.todo.controller;

import com.example.todo.model.Priority;
import com.example.todo.model.Todo;
import com.example.todo.repository.TodoRepository;
import com.fasterxml.jackson.databind.ObjectMapper; // Added for JSON serialization
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Arrays; // Added this import
import java.util.List;
import java.util.Optional;

import static org.hamcrest.Matchers.containsString;
import static org.hamcrest.Matchers.not;
import static org.junit.jupiter.api.Assertions.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@SpringBootTest
@AutoConfigureMockMvc
public class TodoControllerIntegrationTest {

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private TodoRepository todoRepository;

    @Autowired
    private ObjectMapper objectMapper; // Added for JSON serialization

    private Todo task1; // This seems unused, can be removed if setupFilterSortTestData is always used

    @BeforeEach
    void setUp() {
        // Clean up before each test to ensure isolation
        todoRepository.deleteAll();

        // Setup initial data if needed by multiple tests, otherwise create in test methods
        task1 = new Todo();
        task1.setTitle("Initial Task for Tests");
        task1.setCompleted(false);
        // ID will be generated by DB
    }

    @AfterEach
    void tearDown() {
        todoRepository.deleteAll();
    }

    @Test
    void testGetIndex_shouldShowTask() throws Exception {
        Todo savedTask = todoRepository.save(new Todo(0L, "Test Get Index", false, null, null)); // Added null for dueDate and priority

        mockMvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(view().name("index"))
                .andExpect(content().string(containsString("Test Get Index")));
    }

    @Test
    void testPostAdd_shouldCreateTaskAndRedirect() throws Exception {
        LocalDate dueDate = LocalDate.now().plusDays(3);
        String formattedDueDate = dueDate.format(DateTimeFormatter.ISO_DATE);
        Priority priority = Priority.HIGH;

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "New Task via POST");
        params.add("dueDate", formattedDueDate);
        params.add("priority", priority.name());

        mockMvc.perform(post("/add")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        List<Todo> todos = todoRepository.findAll();
        assertEquals(1, todos.size());
        assertEquals("New Task via POST", todos.get(0).getTitle());
        assertEquals(dueDate, todos.get(0).getDueDate());
        assertEquals(priority, todos.get(0).getPriority());
    }

    @Test
    void testPostAdd_withNoPriority_shouldDefaultToMedium() throws Exception {
        LocalDate dueDate = LocalDate.now().plusDays(3);
        String formattedDueDate = dueDate.format(DateTimeFormatter.ISO_DATE);

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "Task with Default Priority");
        params.add("dueDate", formattedDueDate);
        // No priority parameter sent

        mockMvc.perform(post("/add")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        List<Todo> todos = todoRepository.findAll();
        assertEquals(1, todos.size());
        assertEquals("Task with Default Priority", todos.get(0).getTitle());
        assertEquals(Priority.MEDIUM, todos.get(0).getPriority()); // Assuming MEDIUM is default
    }

    @Test
    void testPostDelete_shouldRemoveTaskAndRedirect() throws Exception {
        Todo taskToDelete = todoRepository.save(new Todo(0L, "Task to Delete", false, null, null)); // Added null for dueDate and priority
        Long taskId = taskToDelete.getId();

        mockMvc.perform(post("/delete")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .param("id", String.valueOf(taskId)))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        Optional<Todo> deletedTask = todoRepository.findById(taskId);
        assertFalse(deletedTask.isPresent());
    }

    @Test
    void testPostComplete_shouldMarkTaskAsCompletedAndRedirect() throws Exception {
        Todo taskToComplete = todoRepository.save(new Todo(0L, "Task to Complete", false, null, null)); // Added null for dueDate and priority
        Long taskId = taskToComplete.getId();

        mockMvc.perform(post("/complete")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .param("id", String.valueOf(taskId)))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        Optional<Todo> completedTaskOptional = todoRepository.findById(taskId);
        assertTrue(completedTaskOptional.isPresent());
        assertTrue(completedTaskOptional.get().isCompleted());
    }

    @Test
    void testGetEditId_shouldShowEditFormWithTaskDetails() throws Exception {
        LocalDate dueDate = LocalDate.now().plusDays(5);
        String formattedDueDate = dueDate.format(DateTimeFormatter.ISO_DATE);
        Priority priority = Priority.HIGH;
        Todo taskToEdit = new Todo(0L, "Task to Edit", false, dueDate, priority);
        taskToEdit = todoRepository.save(taskToEdit);
        Long taskId = taskToEdit.getId();

        mockMvc.perform(get("/edit/" + taskId))
                .andExpect(status().isOk())
                .andExpect(view().name("edit-todo"))
                .andExpect(content().string(containsString("Task to Edit")))
                .andExpect(xpath("//input[@name='title']/@value").string("Task to Edit"))
                .andExpect(xpath("//input[@name='dueDate']/@value").string(formattedDueDate))
                .andExpect(xpath("//select[@name='priority']/option[@value='HIGH' and @selected='selected']").exists())
                .andExpect(xpath("//select[@name='priority']/option[@value='MEDIUM']").exists())
                .andExpect(xpath("//select[@name='priority']/option[@value='LOW']").exists());
    }

    @Test
    void testGetEditId_shouldRedirectIfNotFound() throws Exception {
        mockMvc.perform(get("/edit/999")) // Assuming ID 999 does not exist
            .andExpect(status().is3xxRedirection())
            .andExpect(redirectedUrl("/"));
    }


    @Test
    void testPostUpdateId_shouldUpdateTaskAndRedirect() throws Exception {
        LocalDate initialDueDate = LocalDate.now().plusDays(2);
        Priority initialPriority = Priority.LOW;
        Todo taskToUpdate = new Todo(0L, "Original Title", false, initialDueDate, initialPriority);
        taskToUpdate = todoRepository.save(taskToUpdate);
        Long taskId = taskToUpdate.getId();

        LocalDate newDueDate = LocalDate.now().plusDays(7);
        String formattedNewDueDate = newDueDate.format(DateTimeFormatter.ISO_DATE);
        Priority newPriority = Priority.HIGH;

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "Updated Title via POST");
        params.add("dueDate", formattedNewDueDate);
        params.add("priority", newPriority.name());

        mockMvc.perform(post("/update/" + taskId)
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        Optional<Todo> updatedTaskOptional = todoRepository.findById(taskId);
        assertTrue(updatedTaskOptional.isPresent());
        assertEquals("Updated Title via POST", updatedTaskOptional.get().getTitle());
        assertEquals(newDueDate, updatedTaskOptional.get().getDueDate());
        assertEquals(newPriority, updatedTaskOptional.get().getPriority());
    }

    @Test
    void testPostUpdateId_withNoPriority_shouldRetainExistingPriority() throws Exception {
        LocalDate initialDueDate = LocalDate.now().plusDays(2);
        Priority initialPriority = Priority.HIGH;
        Todo taskToUpdate = new Todo(0L, "Original Title", false, initialDueDate, initialPriority);
        taskToUpdate = todoRepository.save(taskToUpdate);
        Long taskId = taskToUpdate.getId();

        String formattedNewDueDate = LocalDate.now().plusDays(5).format(DateTimeFormatter.ISO_DATE);
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "Updated Title Only");
        params.add("dueDate", formattedNewDueDate);
        // No priority parameter sent

        mockMvc.perform(post("/update/" + taskId)
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        Optional<Todo> taskAfterUpdate = todoRepository.findById(taskId);
        assertTrue(taskAfterUpdate.isPresent());
        assertEquals("Updated Title Only", taskAfterUpdate.get().getTitle());
        assertEquals(initialPriority, taskAfterUpdate.get().getPriority()); // Priority should remain unchanged
    }

    @Test
    void testPostUpdateId_shouldNotUpdateIfTitleIsEmptyAndRedirect() throws Exception {
        LocalDate initialDueDate = LocalDate.now().plusDays(2);
        Priority initialPriority = Priority.MEDIUM;
        Todo taskToUpdate = new Todo(0L, "Original Title", false, initialDueDate, initialPriority);
        taskToUpdate = todoRepository.save(taskToUpdate);
        Long taskId = taskToUpdate.getId();

        String formattedNewDueDate = LocalDate.now().plusDays(5).format(DateTimeFormatter.ISO_DATE);

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "  "); // Empty title
        params.add("dueDate", formattedNewDueDate);
        params.add("priority", Priority.HIGH.name());


        mockMvc.perform(post("/update/" + taskId)
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        Optional<Todo> taskAfterUpdate = todoRepository.findById(taskId);
        assertTrue(taskAfterUpdate.isPresent());
        assertEquals("Original Title", taskAfterUpdate.get().getTitle()); // Title should not change
        assertEquals(initialDueDate, taskAfterUpdate.get().getDueDate()); // Due date should also not change
        assertEquals(initialPriority, taskAfterUpdate.get().getPriority()); // Priority should also not change
    }

    @Test
    void testGetIndex_shouldDisplayDueDateAndHighlightOverdueTasksAndPriority() throws Exception {
        LocalDate today = LocalDate.now();
        Todo overdueTask = new Todo(0L, "Overdue Task", false, today.minusDays(1), Priority.HIGH);
        Todo upcomingTask = new Todo(0L, "Upcoming Task", false, today.plusDays(2), Priority.LOW);
        todoRepository.save(overdueTask);
        todoRepository.save(upcomingTask);

        mockMvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(view().name("index"))
                .andExpect(content().string(containsString("Overdue Task")))
                .andExpect(content().string(containsString("task-overdue")))
                .andExpect(xpath("//li[contains(.,'Overdue Task')]//span[contains(@class, 'badge-danger') and text()='High']").exists())
                .andExpect(content().string(containsString("Upcoming Task")))
                .andExpect(xpath("//li[contains(.,'Upcoming Task') and not(contains(@class, 'task-overdue'))]").exists())
                .andExpect(xpath("//li[contains(.,'Upcoming Task')]//span[contains(@class, 'badge-info') and text()='Low']").exists());
    }

    // Helper method to create and save a Todo item
    private Todo createAndSaveTodo(String title, boolean completed, LocalDate dueDate, Priority priority, Todo parent) {
        Todo todo = new Todo(0L, title, completed, dueDate, priority);
        if (parent != null) {
            todo.setParent(parent);
        }
        // Simulate PrePersist if not handled by test environment (usually is)
        if (todo.getCreationDate() == null) {
            todo.setCreationDate(java.time.LocalDateTime.now());
        }
        return todoRepository.save(todo);
    }

    // --- Filter and Sort Tests ---
    private void setupFilterSortTestData() {
        // Ensure a clean slate
        todoRepository.deleteAll();

        // Create tasks one by one to have a predictable creation order for sorting by creationDate
        // All creationDate times will be distinct and in this order.
        // To make creationDate sorting more robust if tests run very fast, small delays could be added,
        // or creationDate set manually if @PrePersist logic allows overriding (e.g. if null).
        // For now, assume persistence order is sufficient.

        // Task 1 (Oldest creation date)
        createAndSaveTodo("Task Charlie (Due Earlier, Low, Completed)", true, LocalDate.now().minusDays(5), Priority.LOW, null);
        // Task 2
        createAndSaveTodo("Task Delta (Overdue, Medium, Pending)", false, LocalDate.now().minusDays(2), Priority.MEDIUM, null);
        // Task 3
        createAndSaveTodo("Task Bravo (Due Today, Medium, Pending)", false, LocalDate.now(), Priority.MEDIUM, null);
        // Task 4
        createAndSaveTodo("Task Alpha (Due Later, High, Pending)", false, LocalDate.now().plusDays(5), Priority.HIGH, null);
        // Task 5
        createAndSaveTodo("Task Foxtrot (Due Next Week, Low, Pending)", false, LocalDate.now().plusDays(7), Priority.LOW, null);
        // Task 6
        createAndSaveTodo("Task Echo (No Due Date, High, Pending)", false, null, Priority.HIGH, null);
        // Task 7 (New specific date task for testing, Newest creation date)
        createAndSaveTodo("Task Golf (Specific Date, Medium, Pending)", false, LocalDate.now().plusYears(1).withMonth(3).withDayOfMonth(15), Priority.MEDIUM, null);

        // Expected order for default sort (creationDate ASC): Charlie, Delta, Bravo, Alpha, Foxtrot, Echo, Golf
        // Expected order for creationDate DESC: Golf, Echo, Foxtrot, Alpha, Bravo, Delta, Charlie
    }

    @Test
    void testFilterByStatus_Pending() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByStatus", "PENDING"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByStatus", "PENDING"))
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Bravo')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Charlie (Due Earlier, Low, Completed)')]").doesNotExist())
                .andExpect(xpath("//li[contains(.,'Task Delta')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Echo')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Foxtrot')]").exists());
    }

    @Test
    void testFilterByStatus_Completed() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByStatus", "COMPLETED"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByStatus", "COMPLETED"))
                .andExpect(xpath("//li[contains(.,'Task Charlie (Due Earlier, Low, Completed)')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").doesNotExist());
    }

    @Test
    void testFilterByPriority_High() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByPriority", "HIGH"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByPriority", Priority.HIGH))
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Echo')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Bravo')]").doesNotExist());
    }

    @Test
    void testFilterByDueDate_Overdue() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByDueDate", "OVERDUE"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByDueDate", "OVERDUE"))
                .andExpect(xpath("//li[contains(.,'Task Delta (Overdue, Medium, Pending)')]").exists())
                // Task Charlie is also overdue by date, but it's completed.
                // The isOverdue() spec itself doesn't check for completion status.
                // So, if ONLY filterByDueDate=OVERDUE is applied, Charlie should be listed.
                // If filterByStatus=PENDING is also applied, then Charlie would be excluded.
                // Let's assume for this specific test, we only care about the due date logic.
                .andExpect(xpath("//li[contains(.,'Task Charlie (Due Earlier, Low, Completed)')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").doesNotExist());
    }

    @Test
    void testFilterByDueDate_Today() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByDueDate", "TODAY"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByDueDate", "TODAY"))
                .andExpect(xpath("//li[contains(.,'Task Bravo (Due Today, Medium)')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").doesNotExist());
    }

    @Test
    void testFilterByDueDate_Next7Days() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("filterByDueDate", "NEXT_7_DAYS"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentFilterByDueDate", "NEXT_7_DAYS"))
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").exists()) // Due in 5 days
                .andExpect(xpath("//li[contains(.,'Task Bravo')]").exists()) // Due today
                .andExpect(xpath("//li[contains(.,'Task Foxtrot')]").exists()) // Due in 7 days
                .andExpect(xpath("//li[contains(.,'Task Delta')]").doesNotExist()); // Overdue
    }

    @Test
    void testSearchTerm() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("searchTerm", "Alpha"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentSearchTerm", "Alpha"))
                .andExpect(xpath("//li[contains(.,'Task Alpha')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Bravo')]").doesNotExist());
    }

    @Test
    void testSortByTitle_ASC() throws Exception {
        setupFilterSortTestData(); // Alpha, Bravo, Charlie, Delta, Echo, Foxtrot
        mockMvc.perform(get("/").param("sortBy", "title").param("sortDir", "ASC"))
                .andExpect(status().isOk())
                .andExpect(model().attribute("currentSortBy", "title"))
                .andExpect(model().attribute("currentSortDir", "ASC"))
                .andExpect(xpath("//ul/li[1][contains(.,'Task Alpha')]").exists())
                .andExpect(xpath("//ul/li[2][contains(.,'Task Bravo')]").exists())
                .andExpect(xpath("//ul/li[3][contains(.,'Task Charlie')]").exists());
    }

    @Test
    void testSortByTitle_DESC() throws Exception {
        setupFilterSortTestData();
        mockMvc.perform(get("/").param("sortBy", "title").param("sortDir", "DESC"))
                .andExpect(status().isOk())
                .andExpect(xpath("//ul/li[1][contains(.,'Task Foxtrot')]").exists())
                .andExpect(xpath("//ul/li[2][contains(.,'Task Echo')]").exists());
    }

    @Test
    void testCombinedFiltersAndSort() throws Exception {
        setupFilterSortTestData();
        // Pending, High priority, sorted by Due Date ASC
        mockMvc.perform(get("/")
                .param("filterByStatus", "PENDING")
                .param("filterByPriority", "HIGH")
                .param("sortBy", "dueDate")
                .param("sortDir", "ASC"))
                .andExpect(status().isOk())
                // Expected: Task Echo (null), Task Alpha (High, due +5d). Both are PENDING and HIGH.
                // Nulls are typically last in ASC sort for dates in H2/PostgreSQL unless specified.
                // Let's verify this behavior or adjust if H2 behaves differently by default.
                // If H2 default is NULLS FIRST for ASC: Echo, Alpha
                // If H2 default is NULLS LAST for ASC: Alpha, Echo
                // The TodoSpecification does not specify null handling for sort, so it's DB dependent.
                // For H2, Sort.by("dueDate").ascending() typically means NULLS LAST.
                .andExpect(xpath("//ul/li[1][contains(.,'Task Alpha (Due Later, High, Pending)')]").exists())
                .andExpect(xpath("//ul/li[2][contains(.,'Task Echo (No Due Date, High, Pending)')]").exists())
                .andExpect(xpath("//li[contains(.,'Task Bravo')]").doesNotExist()); // Medium priority
    }

    @Test
    void testDefaultLoad_SortsByDisplayOrderAsc() throws Exception {
        setupFilterSortTestData(); // Tasks are created with displayOrder 0, 1, 2, 3, 4, 5, 6
        mockMvc.perform(get("/"))
            .andExpect(status().isOk())
            .andExpect(model().attribute("currentSortBy", "displayOrder")) // Default sort is now displayOrder
            .andExpect(model().attribute("currentSortDir", "ASC"))
            // Expected order based on sequential creation in setupFilterSortTestData:
            // Charlie (0), Delta (1), Bravo (2), Alpha (3), Foxtrot (4), Echo (5), Golf (6)
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[1][contains(.,'Task Charlie')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[2][contains(.,'Task Delta')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[3][contains(.,'Task Bravo')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[4][contains(.,'Task Alpha')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[5][contains(.,'Task Foxtrot')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[6][contains(.,'Task Echo')]").exists())
            .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[7][contains(.,'Task Golf')]").exists());
    }

    @Test
    void testFilterByDueDate_SpecificDate() throws Exception {
        setupFilterSortTestData();
        LocalDate specificTestDate = LocalDate.now().plusYears(1).withMonth(3).withDayOfMonth(15);
        String specificDateStr = specificTestDate.format(DateTimeFormatter.ISO_DATE);

        mockMvc.perform(get("/").param("filterByDueDate", specificDateStr))
            .andExpect(status().isOk())
            .andExpect(model().attribute("currentFilterByDueDate", specificDateStr))
            .andExpect(xpath("//li[contains(.,'Task Golf (Specific Date, Medium, Pending)')]").exists())
            .andExpect(xpath("//li[contains(.,'Task Alpha')]").doesNotExist());
    }

    @Test
    void testSortByDueDate_ASC() throws Exception {
        setupFilterSortTestData(); // Echo (null), Charlie (-5d), Delta (-2d), Bravo (today), Alpha (+5d), Foxtrot (+7d), Golf (+1y)
        mockMvc.perform(get("/").param("sortBy", "dueDate").param("sortDir", "ASC"))
            .andExpect(status().isOk())
            .andExpect(model().attribute("currentSortBy", "dueDate"))
            .andExpect(model().attribute("currentSortDir", "ASC"))
            // H2 default: NULLS LAST for ASC sort
            .andExpect(xpath("//ul/li[1][contains(.,'Task Charlie')]").exists()) // -5d
            .andExpect(xpath("//ul/li[2][contains(.,'Task Delta')]").exists())   // -2d
            .andExpect(xpath("//ul/li[3][contains(.,'Task Bravo')]").exists())   // today
            .andExpect(xpath("//ul/li[4][contains(.,'Task Alpha')]").exists())   // +5d
            .andExpect(xpath("//ul/li[5][contains(.,'Task Foxtrot')]").exists()) // +7d
            .andExpect(xpath("//ul/li[6][contains(.,'Task Golf')]").exists())    // +1y
            .andExpect(xpath("//ul/li[7][contains(.,'Task Echo')]").exists());   // null
    }

    @Test
    void testSortByDueDate_DESC() throws Exception {
        setupFilterSortTestData(); // Echo (null), Golf (+1y), Foxtrot (+7d), Alpha (+5d), Bravo (today), Delta (-2d), Charlie (-5d)
        mockMvc.perform(get("/").param("sortBy", "dueDate").param("sortDir", "DESC"))
            .andExpect(status().isOk())
            // H2 default: NULLS FIRST for DESC sort
            .andExpect(xpath("//ul/li[1][contains(.,'Task Echo')]").exists())    // null
            .andExpect(xpath("//ul/li[2][contains(.,'Task Golf')]").exists())    // +1y
            .andExpect(xpath("//ul/li[3][contains(.,'Task Foxtrot')]").exists()) // +7d
            .andExpect(xpath("//ul/li[4][contains(.,'Task Alpha')]").exists())   // +5d
            .andExpect(xpath("//ul/li[5][contains(.,'Task Bravo')]").exists())   // today
            .andExpect(xpath("//ul/li[6][contains(.,'Task Delta')]").exists())   // -2d
            .andExpect(xpath("//ul/li[7][contains(.,'Task Charlie')]").exists()); // -5d
    }

    @Test
    void testSortByPriority_ASC() throws Exception {
        setupFilterSortTestData(); // Priorities: LOW, MEDIUM, MEDIUM, HIGH, LOW, HIGH, MEDIUM
                                   // Sorted by Enum Ordinal: HIGH (0), MEDIUM (1), LOW (2)
                                   // ASC should be HIGH, HIGH, MEDIUM, MEDIUM, MEDIUM, LOW, LOW
        mockMvc.perform(get("/").param("sortBy", "priority").param("sortDir", "ASC"))
            .andExpect(status().isOk())
            // Checking first few based on expected HIGH values, then a MEDIUM
            .andExpect(xpath("//ul/li[1][contains(@class, 'priority-high')]").exists())
            .andExpect(xpath("//ul/li[2][contains(@class, 'priority-high')]").exists())
            .andExpect(xpath("//ul/li[3][contains(@class, 'priority-medium')]").exists());
            // Full list: Alpha(H), Echo(H), Bravo(M), Delta(M), Golf(M), Charlie(L), Foxtrot(L)
            // This requires names to align with priorities for this XPath to work or more complex model assertion
    }

    @Test
    void testSortByPriority_DESC() throws Exception {
        setupFilterSortTestData(); // DESC should be LOW, LOW, MEDIUM, MEDIUM, MEDIUM, HIGH, HIGH
        mockMvc.perform(get("/").param("sortBy", "priority").param("sortDir", "DESC"))
            .andExpect(status().isOk())
            .andExpect(xpath("//ul/li[1][contains(@class, 'priority-low')]").exists())
            .andExpect(xpath("//ul/li[2][contains(@class, 'priority-low')]").exists())
            .andExpect(xpath("//ul/li[3][contains(@class, 'priority-medium')]").exists());
            // Full list: Charlie(L), Foxtrot(L), Bravo(M), Delta(M), Golf(M), Alpha(H), Echo(H)
    }

    @Test
    void testSortByCreationDate_ASC() throws Exception {
        setupFilterSortTestData();
        // Expected order (as created): Charlie, Delta, Bravo, Alpha, Foxtrot, Echo, Golf
        mockMvc.perform(get("/").param("sortBy", "creationDate").param("sortDir", "ASC"))
            .andExpect(status().isOk())
            .andExpect(xpath("//ul/li[1][contains(.,'Task Charlie')]").exists())
            .andExpect(xpath("//ul/li[2][contains(.,'Task Delta')]").exists())
            .andExpect(xpath("//ul/li[3][contains(.,'Task Bravo')]").exists())
            .andExpect(xpath("//ul/li[4][contains(.,'Task Alpha')]").exists())
            .andExpect(xpath("//ul/li[5][contains(.,'Task Foxtrot')]").exists())
            .andExpect(xpath("//ul/li[6][contains(.,'Task Echo')]").exists())
            .andExpect(xpath("//ul/li[7][contains(.,'Task Golf')]").exists());
    }

    @Test
    void testSortByCreationDate_DESC() throws Exception {
        setupFilterSortTestData();
        // Expected order (reverse of creation): Golf, Echo, Foxtrot, Alpha, Bravo, Delta, Charlie
        mockMvc.perform(get("/").param("sortBy", "creationDate").param("sortDir", "DESC"))
            .andExpect(status().isOk())
            .andExpect(xpath("//ul/li[1][contains(.,'Task Golf')]").exists())
            .andExpect(xpath("//ul/li[2][contains(.,'Task Echo')]").exists())
            .andExpect(xpath("//ul/li[3][contains(.,'Task Foxtrot')]").exists())
            .andExpect(xpath("//ul/li[4][contains(.,'Task Alpha')]").exists())
            .andExpect(xpath("//ul/li[5][contains(.,'Task Bravo')]").exists())
            .andExpect(xpath("//ul/li[6][contains(.,'Task Delta')]").exists())
            .andExpect(xpath("//ul/li[7][contains(.,'Task Charlie')]").exists());
    }


    // --- Subtask Tests ---

    @Test
    void testGetAddSubTaskForm_shouldShowForm_whenParentExists() throws Exception {
        Todo parentTask = todoRepository.save(new Todo(0L, "Parent Task for Subtask", false, null, Priority.MEDIUM));
        Long parentId = parentTask.getId();

        mockMvc.perform(get("/task/" + parentId + "/addSubTask"))
                .andExpect(status().isOk())
                .andExpect(view().name("add-subtask"))
                .andExpect(model().attributeExists("parentTask"))
                .andExpect(model().attribute("parentTask", org.hamcrest.Matchers.hasProperty("id", org.hamcrest.Matchers.is(parentId))))
                .andExpect(model().attribute("parentTask", org.hamcrest.Matchers.hasProperty("title", org.hamcrest.Matchers.is("Parent Task for Subtask"))))
                .andExpect(model().attributeExists("subtask"))
                .andExpect(model().attributeExists("priorities"))
                .andExpect(xpath("//p[contains(normalize-space(.), 'Adding subtask to: Parent Task for Subtask')]").exists());
    }

    @Test
    void testGetAddSubTaskForm_shouldRedirect_whenParentNotFound() throws Exception {
        mockMvc.perform(get("/task/999/addSubTask")) // Assuming 999 does not exist
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));
    }

    @Test
    void testPostAddSubTask_shouldCreateSubtaskAndRedirect_whenParentExists() throws Exception {
        Todo parentTask = todoRepository.save(new Todo(0L, "Parent for Subtask", false, null, Priority.MEDIUM));
        Long parentId = parentTask.getId();

        LocalDate dueDate = LocalDate.now().plusDays(1);
        String formattedDueDate = dueDate.format(DateTimeFormatter.ISO_DATE);
        Priority priority = Priority.HIGH;

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("title", "My New Subtask");
        params.add("dueDate", formattedDueDate);
        params.add("priority", priority.name());

        mockMvc.perform(post("/task/" + parentId + "/addSubTask")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .params(params))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/")); // Current redirect

        List<Todo> allTodos = todoRepository.findAll();
        assertEquals(2, allTodos.size()); // Parent and subtask

        Todo savedSubtask = allTodos.stream().filter(t -> "My New Subtask".equals(t.getTitle())).findFirst().orElse(null);
        assertNotNull(savedSubtask);
        assertEquals(dueDate, savedSubtask.getDueDate());
        assertEquals(priority, savedSubtask.getPriority());
        assertNotNull(savedSubtask.getParent());
        assertEquals(parentId, savedSubtask.getParent().getId());

        // Verify parent's subtask list (requires fetching parent again or eager loading)
        // For this test, verifying subtask's parent link is usually sufficient for basic check.
        // More thorough check would involve fetching parent and asserting on its subTasks collection.
    }

    @Test
    void testPostAddSubTask_shouldDoNothing_whenParentNotFound() throws Exception {
        // Attempt to add subtask to a non-existent parent
        mockMvc.perform(post("/task/999/addSubTask")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .param("title", "Subtask for NonExistent Parent")
                        .param("dueDate", LocalDate.now().toString())
                        .param("priority", "MEDIUM"))
                .andExpect(status().is3xxRedirection()) // Controller redirects to / if parent not found (or service returns empty)
                .andExpect(redirectedUrl("/"));

        assertEquals(0, todoRepository.count()); // No tasks should have been created
    }


    @Test
    void testGetIndex_shouldDisplayTasksWithNestedSubtasks() throws Exception {
        Todo parent = new Todo(0L, "Parent Task", false, null, Priority.MEDIUM);
        parent = todoRepository.save(parent);

        Todo subtask1 = new Todo(0L, "Subtask 1", false, null, Priority.HIGH);
        subtask1.setParent(parent);
        todoRepository.save(subtask1);

        Todo subtask2 = new Todo(0L, "Subtask 2", true, LocalDate.now().plusDays(1), Priority.LOW);
        subtask2.setParent(parent);
        todoRepository.save(subtask2);

        // Refresh parent to ensure subtasks are loaded if accessed (though not strictly needed for this XPath test)
        // parent = todoRepository.findById(parent.getId()).get();


        mockMvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(xpath("//li[contains(.,'Parent Task')]").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul[contains(@class, 'subtask-list')]").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul/li[contains(.,'Subtask 1')]").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul/li[contains(.,'Subtask 1')]//span[contains(@class, 'badge-danger') and text()='High']").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul/li[contains(.,'Subtask 2')]").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul/li[contains(.,'Subtask 2')]//span[@class='completed']").exists())
                .andExpect(xpath("//li[contains(.,'Parent Task')]//ul/li[contains(.,'Subtask 2')]//span[contains(@class, 'badge-info') and text()='Low']").exists());
    }

    @Test
    void testDeleteParentTask_shouldCascadeDeleteSubtasks() throws Exception {
        Todo parent = new Todo(0L, "Parent With Subtasks", false, null, Priority.MEDIUM);
        parent = todoRepository.save(parent);
        Long parentId = parent.getId();

        Todo subtask1 = new Todo(0L, "Subtask To Delete 1", false, null, Priority.HIGH);
        subtask1.setParent(parent);
        todoRepository.save(subtask1);
        Long subtask1Id = subtask1.getId();

        Todo subtask2 = new Todo(0L, "Subtask To Delete 2", false, null, Priority.LOW);
        subtask2.setParent(parent);
        todoRepository.save(subtask2);
        Long subtask2Id = subtask2.getId();

        assertEquals(3, todoRepository.count());

        mockMvc.perform(post("/delete")
                        .contentType(MediaType.APPLICATION_FORM_URLENCODED)
                        .param("id", String.valueOf(parentId)))
                .andExpect(status().is3xxRedirection())
                .andExpect(redirectedUrl("/"));

        assertEquals(0, todoRepository.count()); // Parent and both subtasks should be gone
        assertFalse(todoRepository.findById(parentId).isPresent());
        assertFalse(todoRepository.findById(subtask1Id).isPresent());
        assertFalse(todoRepository.findById(subtask2Id).isPresent());
    }

    @Test
    void testGetEditId_shouldDisplayParentAndSubtaskInfo() throws Exception {
        // Parent Task
        Todo parentTask = new Todo(0L, "Main Project Task", false, LocalDate.now().plusDays(10), Priority.HIGH);
        parentTask = todoRepository.save(parentTask);

        // Subtask
        Todo subTask = new Todo(0L, "Sub-feature A", false, LocalDate.now().plusDays(5), Priority.MEDIUM);
        subTask.setParent(parentTask);
        todoRepository.save(subTask);
        // Refresh parent to have subTasks collection populated for the assertion if not using JOIN FETCH
        // parentTask.addSubTask(subTask); // Handled by subTask.setParent() and JPA if bidirectional utility is used
        // todoRepository.save(parentTask); // Not strictly necessary if cascade is set up from subtask to parent (which it isn't, parent is owning side)
                                        // or if we re-fetch parent below.

        // Test editing the parent task
        mockMvc.perform(get("/edit/" + parentTask.getId()))
            .andExpect(status().isOk())
            .andExpect(xpath("//h5[text()='Subtasks:']").exists())
            .andExpect(xpath("//ul/li[contains(.,'Sub-feature A')]").exists());

        // Test editing the subtask
        mockMvc.perform(get("/edit/" + subTask.getId()))
            .andExpect(status().isOk())
            .andExpect(xpath("//p[contains(.,'This is a subtask of:')]//strong[text()='Main Project Task']").exists())
            .andExpect(xpath("//p//a[contains(text(),'(Edit Parent)') and @href='/edit/" + parentTask.getId() + "']").exists());
    }

    // --- Tests for /todos/reorder endpoint ---

    @Test
    void testReorderTasks_topLevel_shouldUpdateDisplayOrderAndReflectInView() throws Exception {
        // Setup: Create 3 top-level tasks. Their initial displayOrder will be 0, 1, 2.
        Todo t1 = createAndSaveTodo("Task 1 Original Order 0", false, null, Priority.MEDIUM, null); // displayOrder 0
        Todo t2 = createAndSaveTodo("Task 2 Original Order 1", false, null, Priority.MEDIUM, null); // displayOrder 1
        Todo t3 = createAndSaveTodo("Task 3 Original Order 2", false, null, Priority.MEDIUM, null); // displayOrder 2

        TodoController.ReorderRequestPayload payload = new TodoController.ReorderRequestPayload();
        payload.setOrderedTaskIds(Arrays.asList(t3.getId(), t1.getId(), t2.getId())); // New order: t3, t1, t2
        payload.setParentId(null);

        mockMvc.perform(post("/todos/reorder")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload))
                        .with(org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf()))
                .andExpect(status().isOk());

        // Verify displayOrder in DB
        assertEquals(0, todoRepository.findById(t3.getId()).get().getDisplayOrder());
        assertEquals(1, todoRepository.findById(t1.getId()).get().getDisplayOrder());
        assertEquals(2, todoRepository.findById(t2.getId()).get().getDisplayOrder());

        // Verify HTML order on GET /
        mockMvc.perform(get("/"))
                .andExpect(status().isOk())
                .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[1][contains(.,'Task 3')]").exists())
                .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[2][contains(.,'Task 1')]").exists())
                .andExpect(xpath("//ul[contains(@class,'sortable-list') and not(contains(@class,'subtask-list'))]/li[3][contains(.,'Task 2')]").exists());
    }

    @Test
    void testReorderTasks_subtasks_shouldUpdateDisplayOrderAndReflectInView() throws Exception {
        Todo parent = createAndSaveTodo("Parent Task", false, null, Priority.HIGH, null);
        Todo s1 = createAndSaveTodo("Subtask 1 Original Order 0", false, null, Priority.MEDIUM, parent); // displayOrder 0
        Todo s2 = createAndSaveTodo("Subtask 2 Original Order 1", false, null, Priority.MEDIUM, parent); // displayOrder 1
        Todo s3 = createAndSaveTodo("Subtask 3 Original Order 2", false, null, Priority.MEDIUM, parent); // displayOrder 2

        TodoController.ReorderRequestPayload payload = new TodoController.ReorderRequestPayload();
        payload.setOrderedTaskIds(Arrays.asList(s3.getId(), s1.getId(), s2.getId())); // New order: s3, s1, s2
        payload.setParentId(parent.getId());

        mockMvc.perform(post("/todos/reorder")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload))
                        .with(org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf()))
                .andExpect(status().isOk());

        assertEquals(0, todoRepository.findById(s3.getId()).get().getDisplayOrder());
        assertEquals(1, todoRepository.findById(s1.getId()).get().getDisplayOrder());
        assertEquals(2, todoRepository.findById(s2.getId()).get().getDisplayOrder());

        mockMvc.perform(get("/"))
            .andExpect(status().isOk())
            .andExpect(xpath("//li[@data-task-id='" + parent.getId() + "']//ul[@class='subtask-list list-unstyled sortable-list']/li[1][contains(.,'Subtask 3')]").exists())
            .andExpect(xpath("//li[@data-task-id='" + parent.getId() + "']//ul[@class='subtask-list list-unstyled sortable-list']/li[2][contains(.,'Subtask 1')]").exists())
            .andExpect(xpath("//li[@data-task-id='" + parent.getId() + "']//ul[@class='subtask-list list-unstyled sortable-list']/li[3][contains(.,'Subtask 2')]").exists());
    }

    @Test
    void testReorderTasks_invalidPayload_shouldReturnBadRequest() throws Exception {
        TodoController.ReorderRequestPayload payload = new TodoController.ReorderRequestPayload();
        payload.setOrderedTaskIds(null); // Invalid: missing orderedTaskIds

        mockMvc.perform(post("/todos/reorder")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload))
                        .with(org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf()))
                .andExpect(status().isBadRequest());
    }

    @Test
    void testReorderTasks_taskNotFound_shouldHandleGracefullyAndReorderExisting() throws Exception {
        Todo t1 = createAndSaveTodo("Task 1 Exists", false, null, Priority.MEDIUM, null);
        Todo t2 = createAndSaveTodo("Task 2 Exists", false, null, Priority.MEDIUM, null);

        TodoController.ReorderRequestPayload payload = new TodoController.ReorderRequestPayload();
        // Order: t1, then a non-existent task, then t2
        payload.setOrderedTaskIds(Arrays.asList(t1.getId(), 9999L, t2.getId()));
        payload.setParentId(null);

        mockMvc.perform(post("/todos/reorder")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload))
                        .with(org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf()))
                .andExpect(status().isOk()); // Service handles this gracefully

        // Existing tasks should be reordered based on their presence in the list
        // t1 is at index 0, t2 is at index 2 (but after 999L is skipped, it's effectively index 1)
        assertEquals(0, todoRepository.findById(t1.getId()).get().getDisplayOrder());
        assertEquals(1, todoRepository.findById(t2.getId()).get().getDisplayOrder());
    }

    @Test
    void testReorderTasks_taskDoesNotMatchParentContext_shouldHandleGracefully() throws Exception {
        Todo topLevelTask = createAndSaveTodo("Top Level Task", false, null, Priority.MEDIUM, null); // displayOrder 0
        Todo parentForSubtask = createAndSaveTodo("Parent For Subtask", false, null, Priority.HIGH, null); // displayOrder 1
        Todo subtask = createAndSaveTodo("Subtask", false, null, Priority.LOW, parentForSubtask); // displayOrder 0 (for this parent)

        TodoController.ReorderRequestPayload payload = new TodoController.ReorderRequestPayload();
        // Attempt to reorder topLevelTask and subtask as if they are both top-level
        payload.setOrderedTaskIds(Arrays.asList(subtask.getId(), topLevelTask.getId()));
        payload.setParentId(null);

        mockMvc.perform(post("/todos/reorder")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(payload))
                        .with(org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.csrf()))
                .andExpect(status().isOk());

        // topLevelTask should be reordered (it's the only one matching parentId=null context)
        // Its new order will be 0 as it's the first valid task in the list for this context.
        assertEquals(0, todoRepository.findById(topLevelTask.getId()).get().getDisplayOrder());
        // subtask's displayOrder should remain unchanged (0 relative to its parent) as it was skipped
        assertEquals(0, todoRepository.findById(subtask.getId()).get().getDisplayOrder());
        assertNotNull(todoRepository.findById(subtask.getId()).get().getParent()); // ensure it's still a subtask
    }


    // --- Test @OrderBy on subTasks collection ---
    @Test
    void testParentEntity_loadsSubtasks_inDisplayOrder() throws Exception {
        Todo parent = createAndSaveTodo("Parent With Unordered Subtasks", false, null, Priority.HIGH, null);

        // Create subtasks and save them deliberately out of displayOrder sequence
        // Service's addSubTask sets displayOrder, so we manually set and save for test
        Todo sub2 = new Todo();
        sub2.setTitle("Subtask B");
        sub2.setParent(parent);
        sub2.setDisplayOrder(1); // Explicitly set order
        todoRepository.save(sub2);

        Todo sub1 = new Todo();
        sub1.setTitle("Subtask A");
        sub1.setParent(parent);
        sub1.setDisplayOrder(0); // Explicitly set order
        todoRepository.save(sub1);

        Todo sub3 = new Todo();
        sub3.setTitle("Subtask C");
        sub3.setParent(parent);
        sub3.setDisplayOrder(2); // Explicitly set order
        todoRepository.save(sub3);

        // Fetch the parent task
        Optional<Todo> fetchedParentOptional = todoRepository.findById(parent.getId());
        assertTrue(fetchedParentOptional.isPresent());
        Todo fetchedParent = fetchedParentOptional.get();

        // Access subTasks - @OrderBy should ensure they are sorted by displayOrder
        List<Todo> subTasks = fetchedParent.getSubTasks();
        assertNotNull(subTasks);
        assertEquals(3, subTasks.size());
        assertEquals("Subtask A", subTasks.get(0).getTitle()); // Expected order 0
        assertEquals(0, subTasks.get(0).getDisplayOrder());
        assertEquals("Subtask B", subTasks.get(1).getTitle()); // Expected order 1
        assertEquals(1, subTasks.get(1).getDisplayOrder());
        assertEquals("Subtask C", subTasks.get(2).getTitle()); // Expected order 2
        assertEquals(2, subTasks.get(2).getDisplayOrder());
    }
}
